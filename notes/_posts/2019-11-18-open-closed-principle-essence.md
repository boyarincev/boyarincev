---
title: Суть принципа Open-Closed
tags: SOLID
published: false
---

Вообще есть такое чувство, что в 2к19 SOLID-принципы уже как-то совсем устарели, никто вокруг про них не говорит и не пишет, но если вдруг вспоминать о них, то Open-Closed в них самый неоднозначный.

Если посмотреть на формальное определение: "Модули открыты для расширения, но закрыты для модификации" - то с первой частью всё более менее понятно, 
продумываем дизайн модуля так, чтобы его поведение было расширяемо, все в общем-то, объясняя этот принцип и сосредотачиваются на этой первой части, показывая разные подходы к расширяемости, но что значит вторая часть?

"Модули закрыты для модификации" - Чего мы достигаем закрывая модули от модификации, какую цель преследует этот запрет? Мы теперь совсем не должны вносить изменения прямо в модули? Как правильно закрывать модули от модификации?

Для объяснений [слово предоставляется Роберту Мартину](https://blog.cleancoder.com/uncle-bob/2013/03/08/AnOpenAndClosedCase.html), который и популяризировал этот принцип и через 17 лет после этого решил подробнее объяснить, что значит вторая часть принципа:

> It should be easy to change the behavior of a module without changing the source code of that module. 

То есть, при следовании этому принципу точки расширения должны позволять нам произвести расширения модуля не трогая его исходный код, это может быть полезно, например, когда у нас нет доступа к этому исходному коду.
Но из этого не следует, что модуль должен быть закрыт для модификации - это дополнительные требования к тому, как нужно продумать дизайн расширяемости модуля.

> This doesn’t mean you will never change the source code, this doesn’t mean you can stop using your version control systems (sheesh!). 

Ну вот, похоже, что Роберт Мартин согласен со мной.

> What it means is that you should strive to get your code into a position such that, when behavior changes in expected ways, you don’t have to make sweeping changes to all the modules of the system. 

А вот это что-то новенькое - изменения поведения модуля не должны вызывать каскад изменений в системе - но это тоже больше про дизайн расширяемости, про сокрытие информации и инкапсуляцию, но ничего про отказ от модификации модуля тут нет.

> Ideally, you will be able to add the new behavior by adding new code, and changing little or no old code.

А тут уже взгляд немного под другим углом - дизайн расширяемости должен позволять добавление нового поведения без изменения старого кода - могу предположить, что это может быть полезно, если мы не хотим проводить тестирование старого функционала, после внесения изменений в старый код. Но тут тоже ничего нет про то, что мы должны отказаться от модификации этого старого кода, когда не против провести тестирование.

Но вообще в итоге не сказать, что стало намного понятнее.

