---
title: Volatile, барьеры памяти, модели памяти, неблокирующая синхронизация и прочие умные слова
tags: multithreading
published: false
---

Сегодня будем разбираться с Volatile и всем, что с ним связано. Тема эта интересна тем, что чтобы полностью её понимать необходимо опуститься вплоть до уровня процессора и даже узнать чем отличаются разные процессорные архитектуры в плане работы с памятью. Так как материал очень объёмный, то как всегда не буду пытаться, что-то объяснить сам, а буду давать ссылки.

У Рихтера в книге для Volatile отведёно 7 страниц и этого сильно недостаточно. Но давайте для начала повторим основные тезисы Рихтера.

> Компилятор C#, JIT-компилятор и даже сам процессор могут оптимизировать ваш код.
> В процессе оптимизации кода компилятором C#, JIT-компилятором и процессором гарантируется сохранение его назначения. То есть с точки зрения одного потока метод делает то, зачем мы его написали, хотя способ реализации может отличаться от описанного  исходном коде. Однако при переходе к многопоточной конфигурации ситуация может измениться.

Самое главное, что вам нужно понимать - если у вас многопоточное приложение с разделяемыми несколькими потоками данными (например полями класса), то у вас нет гарантии того, что данные в эти разделяемые поля будут записаны и прочитаны потоком именно в том порядке, в котором вы их написали в своём коде.

```csharp
a = 5;
b = 10;
flag = true;
```

.NET не гарантирует, что эти записи в переменные будут произведены именно в этом порядке, поэтому если вы хотите написать код, в котором один поток, сначала заполняет, какие-то данные, а потом проставляет флаг в true, второй поток проверяет значение флага и начинает работать только тогда, когда он выставлен в true, то без использования специальных средств, у вас нет гарантий, что этот код будет работать так как вы его задумали.

Что же может сделать этот код работоспособным? - Методы Volatile.Write и Volatile.Read

> Метод Volatile.Write заставляет записать значение в параметр location непосредственно в момент обращения. Бодее ранние загрузки и сохранения программы должны происходить до вызова этого метода.
> Метод Volatile.Read заставляет считать значение параметра address непосредственно в момент обращения. Более поздние загрузки и сохранения программы должны происходить после вызова этого метода.

Или ключевое слово volatile применённое к полям

> JIT-компилятор гарантирует, что доступ к полям, помеченным данным ключевым словом, будет происходить в режиме волатильного чтения или записи, поэтому в явном виде вызывать статические методы Read и Write класса Volatile больше не требуется.

Из Рихтера можно узнать основные моменты, но если у вас есть желание погрузиться гораздо глубже, то рекомендую прослушать выступление Валерия Петрова: 

[Модель памяти .NET](https://youtu.be/m9_aBxdKrRI)

Доклад отличный, мне нравится, что Валерий для доказательства своих слов приводит ссылки на источники и попутно опровергает несколько широко тиражируемых мифов
