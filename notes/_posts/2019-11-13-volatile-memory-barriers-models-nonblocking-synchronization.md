---
title: Volatile, барьеры памяти, модели памяти, неблокирующая синхронизация и прочие умные слова
tags: multithreading
published: false
---

Сегодня будем разбираться с Volatile и всем, что с ним связано. Тема эта интересна тем, что чтобы полностью её понимать необходимо опуститься вплоть до уровня процессора и даже узнать чем отличаются разные процессорные архитектуры в плане работы с памятью. Так как материал очень объёмный, то как всегда не буду пытаться, что-то объяснить сам, а буду давать ссылки.

У Рихтера в книге для Volatile отведёно 7 страниц и этого сильно недостаточно. Но давайте для начала повторим основные тезисы Рихтера.

> Компилятор C#, JIT-компилятор и даже сам процессор могут оптимизировать ваш код.
> В процессе оптимизации кода компилятором C#, JIT-компилятором и процессором гарантируется сохранение его назначения. То есть с точки зрения одного потока метод делает то, зачем мы его написали, хотя способ реализации может отличаться от описанного  исходном коде. Однако при переходе к многопоточной конфигурации ситуация может измениться.

Самое главное, что вам нужно понимать - если у вас многопоточное приложение с разделяемыми несколькими потоками данными (например полями класса), то у вас нет гарантии того, что данные в эти разделяемые поля будут записаны и прочитаны потоком именно в том порядке, в котором вы их написали в своём коде.

```csharp
a = c;
b = d;
flag = true;
```

.NET не гарантирует, что эти чтения и записи в переменные будут произведены именно в этом порядке, поэтому если вы хотите написать код, в котором один поток, сначала читает, какие-то данные, а потом проставляет флаг в true, второй поток проверяет значение флага и начинает работать только тогда, когда он выставлен в true, то без использования специальных средств, у вас нет гарантий, что этот код будет работать так как вы его задумали.

Что же может сделать этот код работоспособным? - Методы Volatile.Write и Volatile.Read

> Метод Volatile.Write заставляет записать значение в параметр location непосредственно в момент обращения. Бодее ранние загрузки и сохранения программы должны происходить до вызова этого метода.
> Метод Volatile.Read заставляет считать значение параметра address непосредственно в момент обращения. Более поздние загрузки и сохранения программы должны происходить после вызова этого метода.

Или ключевое слово volatile применённое к полям

> JIT-компилятор гарантирует, что доступ к полям, помеченным данным ключевым словом, будет происходить в режиме волатильного чтения или записи, поэтому в явном виде вызывать статические методы Read и Write класса Volatile больше не требуется.

Из Рихтера можно узнать основные моменты, но чтобы понять тему, нужно погружаться гораздо глубже. И продолжить изучать тему можно с помощью доклада Валерия Петрова: 

[Модель памяти .NET](https://youtu.be/m9_aBxdKrRI)

Из доклада можно узнать:

- Почему процессоры переставляют выполняемые инструкции местами
- Какие оптимизации могут произвести с вашим кодом Компилятор/JIT/CPU
- Что такое модель памяти и при чём тут она
- Как работает ключевое слово volatile и методы Volatile.Write и Volatile.Read и как правильно их использовать

Кроме того, что в докладе очень доступная подача материала, мне нравится ещё то, что Валерий для подтверждения своих слов приводит ссылки на пункты спецификации.

Также я нашёл [презентацию](https://assets.ctfassets.net/9n3x4rtjlya6/1qv4heo4zqacgK8mW08gq6/a1932b7e65403db9cfad1cd0dc2fdb75/Valery_Petrov-Memory_Model_rev2.pdf) Валерия Петрова, но видимо она сделана к какому-то другому докладу, потому что слайдов в ней намного больше и больше разного материала затронуто.

Хочется остановится на определении модели памяти

Согласно [википедии](https://en.wikipedia.org/wiki/Memory_model_(programming)):

> In computing, a memory model describes the interactions of threads through memory and their shared use of the data.
> A memory model allows a compiler to perform many important optimizations. Compiler optimizations like loop fusion move statements in the program, which can influence the order of read and write operations of potentially shared variables. Changes in the ordering of reads and writes can cause race conditions. Without a memory model, a compiler is not allowed to apply such optimizations to multi-threaded programs in general, or only in special cases.

Мне это определение не кажется понятным, но грубый смысл вынести можно такой:

> Это разрешения, которые есть у компилятора на проведение оптимизаций, которые могут повлиять на порядок операций чтения и записи, которые могут производиться с памятью, с которой работают несколько потоков одновременно, что в свою очередь может привести к багу в работе какого-либо потока.

На хабре также есть статья, которая довольно близка к докладу Валерия по кругу разбираемых вопросов:

[Барьеры памяти и неблокирующая синхронизация в .NET](https://habr.com/ru/post/130318/) от Дмитрия Костикова.

В ней материал тоже подаётся вполне доступно, но есть несколько комментариев от меня:

1. Написано, что в модели памяти .NET разрешены все перестановки кроме write-write - Валерий Петров упоминает, в своём докладе, что об этом часто пишут в статьях, но неизвестно откуда взялся этот факт и насколько он соответствует действительности, в спецификациях или каких-либо других источниках его подтверждение найти не удалось.

2. В самом конце статьи в разделе "Производительность Thread.Volatile* и ключевого слово volatile" написано, что: "На большинстве платформ (точнее говоря, на всех платформах, поддерживаемых Windows, кроме умирающей IA64) все записи и чтения являются volatile write и volatile read соответственно. Таким образом, во время выполнения ключевое слово volatile не оказывает никакого влияния на производительность." - Текст неактуальный на данный момент, так как с тех пор появилась поддержка ARM-процессоров и так как в статье, не были затронуты особенности разных процессорных архитектур в плане перестановок инструкций и то как на них влияет volatile, то этот параграф всё-равно будет непонятен неподготовленному читателю. Также лично мне не кажется удачной формулировка, что запись и чтения на платформах являются волатильными, но об этом позже.

Какие ещё статьи есть:

- Есть ещё статья Джо Албахари [Threading in C# PART 4: ADVANCED THREADING](http://www.albahari.com/threading/part4.aspx) первая часть, которой посвящена неблокирующей синхронизации в общем и volatile в частности, но эту статью я читать не рекомендую - слишком много утверждений, которые либо не понятны, либо которые я не могу подтвердить.


Если вы прочитали/прослушали материалы выше, то теперь вы знаете интересные факты о том, что в .NET

- Вызов Volatile.Write/Volatile.Read идентичны использованию ключевого слова volatile в плане получаемых эффектов на выполнение кода, а вот вызов Thread.VolatileWrite/Thread.VolatileRead - ведут себя по другому.
- Волатильная запись и последующее волатильное чтение могут быть переставлены местами (но это не только в .NET)
- lock и Interlocked в своей работе используют aquire/release семантику (объяснить, расписать)
