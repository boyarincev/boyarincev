---
title: Volatile, барьеры памяти, модели памяти, неблокирующая синхронизация и прочие умные слова
tags: multithreading
published: false
---

Сегодня будем разбираться с Volatile и всем, что с ним связано. Тема эта интересна тем, что чтобы полностью её понимать необходимо опуститься вплоть до уровня процессора и даже узнать чем отличаются разные процессорные архитектуры в плане работы с памятью. Так как материал очень объёмный, то как всегда не буду пытаться, что-то объяснить сам, а буду давать ссылки.

## Суперкратко


## Теперь длинно

У Рихтера в книге для Volatile отведёно 7 страниц, хотя этого явно недостаточно. Но давайте для начала повторим основные тезисы Рихтера.

> Компилятор C#, JIT-компилятор и даже сам процессор могут оптимизировать ваш код.
> В процессе оптимизации кода компилятором C#, JIT-компилятором и процессором гарантируется сохранение его назначения. То есть с точки зрения одного потока метод делает то, зачем мы его написали, хотя способ реализации может отличаться от описанного  исходном коде. Однако при переходе к многопоточной конфигурации ситуация может измениться.

Самое главное, что вам нужно понимать - если у вас многопоточное приложение с разделяемыми несколькими потоками данными (например полями класса), то у вас нет гарантии того, что данные в эти разделяемые поля будут записаны одним потоком и прочитаны другим потоком именно в том порядке, в котором вы их написали в своём коде.

```csharp
a = c;
b = d;
flag = true;
```

.NET не гарантирует, что чтения и записи выше будут произведены именно в этом порядке, поэтому если вы хотите написать код, в котором один поток, сначала читает, какие-то данные, а потом проставляет флаг в true, второй поток проверяет значение флага и начинает работать только тогда, когда он выставлен в true, то без использования специальных средств, у вас нет гарантий, что этот код будет работать так как вы его задумали.

Что же может сделать этот код работоспособным? - Методы Volatile.Write и Volatile.Read

> Метод Volatile.Write заставляет записать значение в параметр location непосредственно в момент обращения. Бодее ранние загрузки и сохранения программы должны происходить до вызова этого метода.
> Метод Volatile.Read заставляет считать значение параметра address непосредственно в момент обращения. Более поздние загрузки и сохранения программы должны происходить после вызова этого метода.

Или ключевое слово volatile применённое к полям

> JIT-компилятор гарантирует, что доступ к полям, помеченным данным ключевым словом, будет происходить в режиме волатильного чтения или записи, поэтому в явном виде вызывать статические методы Read и Write класса Volatile больше не требуется.

Из Рихтера можно узнать основные моменты, но чтобы понять тему, нужно погружаться гораздо глубже. И продолжить изучать тему можно с помощью доклада Валерия Петрова: 

[Модель памяти .NET](https://youtu.be/m9_aBxdKrRI)

Из доклада можно узнать:

- Почему процессоры переставляют выполняемые инструкции местами
- Какие оптимизации могут произвести с вашим кодом Компилятор/JIT/CPU
- Что такое модель памяти и при чём тут она
- Как работает ключевое слово volatile и методы Volatile.Write и Volatile.Read и как правильно их использовать

Кроме того, что в докладе очень доступная подача материала, мне нравится ещё то, что Валерий для подтверждения своих слов приводит ссылки на пункты спецификации.

Также я нашёл [презентацию](https://assets.ctfassets.net/9n3x4rtjlya6/1qv4heo4zqacgK8mW08gq6/a1932b7e65403db9cfad1cd0dc2fdb75/Valery_Petrov-Memory_Model_rev2.pdf) Валерия Петрова, но видимо она сделана к какому-то другому докладу, потому что слайдов в ней намного больше и больше разного материала затронуто.

Хочется остановится на определении модели памяти

Согласно [википедии](https://en.wikipedia.org/wiki/Memory_model_(programming)):

> In computing, a memory model describes the interactions of threads through memory and their shared use of the data.
> A memory model allows a compiler to perform many important optimizations. Compiler optimizations like loop fusion move statements in the program, which can influence the order of read and write operations of potentially shared variables. Changes in the ordering of reads and writes can cause race conditions. Without a memory model, a compiler is not allowed to apply such optimizations to multi-threaded programs in general, or only in special cases.

Мне это определение не кажется доступным и понятным, но грубый смысл вынести можно такой:

> Модель памяти - это разрешения, которые есть у компилятора на проведение оптимизаций, которые могут повлиять на порядок операций чтения и записи, которые могут производиться с памятью, с которой работают несколько потоков одновременно, что в свою очередь может привести к багу в работе какого-либо потока.

На хабре также есть статья, которая довольно близка к докладу Валерия по кругу разбираемых вопросов:

[Барьеры памяти и неблокирующая синхронизация в .NET](https://habr.com/ru/post/130318/) от Дмитрия Костикова.

В ней материал тоже подаётся вполне доступно, но есть несколько комментариев от меня:

1. Написано, что в модели памяти .NET разрешены все перестановки кроме write-write - Валерий Петров упоминает, в своём докладе, что об этом часто пишут в статьях, но неизвестно откуда взялся этот факт и насколько он соответствует действительности, в спецификациях или каких-либо других источниках его подтверждение найти не удалось.

2. Материал непосредственно про барьеры памяти мне кажется изложен не очень понятно.

3. В самом конце статьи в разделе "Производительность Thread.Volatile* и ключевого слово volatile" написано, что: "На большинстве платформ (точнее говоря, на всех платформах, поддерживаемых Windows, кроме умирающей IA64) все записи и чтения являются volatile write и volatile read соответственно. Таким образом, во время выполнения ключевое слово volatile не оказывает никакого влияния на производительность." - Текст неактуальный на данный момент, так как с тех пор появилась поддержка ARM-процессоров, а так как в статье, не были затронуты особенности разных процессорных архитектур в плане перестановок инструкций и то как на них влияет volatile, то этот параграф всё-равно будет непонятен неподготовленному читателю. Также лично мне не кажется удачной формулировка, что запись и чтения на платформах являются волатильными, но об этом позже.

Какие ещё есть статьи, которые, в принципе, можно пропустить:

- Есть ещё статья Джо Албахари [Threading in C# PART 4: ADVANCED THREADING](http://www.albahari.com/threading/part4.aspx) первая часть, которой посвящена неблокирующей синхронизации в общем и volatile в частности - присутствуют утверждения, которые либо не понятны, либо которые я не знаю как подтвердить.
- [Модель памяти C# в теории и на практике](https://docs.microsoft.com/ru-ru/archive/msdn-magazine/2012/december/csharp-the-csharp-memory-model-in-theory-and-practice) Игоря Островского - к этой статье тоже есть вопросы в плане используемых утверждений и формулировок.
- [C# - The C# Memory Model in Theory and Practice, Part 2](https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/january/csharp-the-csharp-memory-model-in-theory-and-practice-part-2) - Вторая часть статьи Игоря Островского про модель памяти, в этой статье разбираются три вида оптимизаций, которые может произвести с кодом компилятор, а также особенности работы volatile на архитектурах x86/x64, Itanium, ARM - материал про особенности конкретных архитектур может представлять интерес.

Если вы прочитали/прослушали материалы выше, то теперь вы знаете интересные факты о том, что в .NET

- Вызов Volatile.Write/Volatile.Read идентичны использованию ключевого слова volatile в плане получаемых эффектов на выполнение кода, а вот вызов Thread.VolatileWrite/Thread.VolatileRead - ведут себя по другому.
- Волатильная запись и последующее волатильное чтение могут быть переставлены местами (но это не только в .NET)
- lock и Interlocked в своей работе используют aquire/release семантику (объяснить, расписать - нужно вообще?)

Пришло время разобраться с [барьерами памяти](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%80%D1%8C%D0%B5%D1%80_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8):

> Барьер памяти - вид барьерной инструкции, которая приказывает компилятору (при генерации инструкций) и центральному процессору (при исполнении инструкций) устанавливать строгую последовательность между обращениями к памяти до и после барьера. Это означает, что все обращения к памяти перед барьером будут гарантированно выполнены до первого обращения к памяти после барьера.

Использование ключевого слова volatile или методов Volatile.Read/Write - это один из способов установить барьер памяти, Thread.MemoryBarier - другой.

Статья на эту тему:

[Memory Barriers in .NET](https://afana.me/archive/2015/07/10/memory-barriers-in-dot-net.aspx) некоего Nadeem Afana.

Статья интересна тем, что рассматривает вопрос барьеров памяти с точки зрения работы процессора.

Моий замечания к статье:

И если есть желание разбираться дальше, то нужно опускаться до уровня процессора, потому что на уровне компилятора C# и JIT-компилятора мы можем отключить оптимизации, но процессор продолжит эти оптимизации производить, поэтому их нужно выключить и на нём.
