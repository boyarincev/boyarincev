---
layout: post
title: Представление чисел с плавающей точкой в памяти в дотнете
tags: floating-point-numbers
published: false
---

Это не полноценная статья, я не буду подробно рассказывать о устройстве чисел с плавающей точкой, а порекомендую ссылки на другие статьи рассказывающие об этом:

У Джона Скита есть две коротенькие статьи на эту тему, первая [Binary floating point and .NET](https://csharpindepth.com/Articles/FloatingPoint) про double и float, вторая [Decimal floating point in .NET](https://csharpindepth.com/Articles/Decimal) про decimal, можно сначала прочитать их.

Сам Скит рекомендует к прочтению эту статью: [Floating Point in .NET part 1: Concepts and Formats](https://www.extremeoptimization.com/resources/Articles/FPDotNetConceptsAndFormats.aspx) - она  более подробная и позволит уже более основательно разобраться в вопросе.

В этой статье я только разберу, конкретные байтовые представления чисел в памяти, подробно остановившись на том, как они получаются. Мне кажется, таких конкретных примеров не хватает в статьях выше для лучшего понимания.

## Кратко о том как Double хранится в памяти 



## Как можно получить байтовое представление Double
[Класс BitConverter](https://docs.microsoft.com/ru-ru/dotnet/api/system.bitconverter?view=netframework-4.8) позволяет получить байтовое представление базовых типов или наоборот преобразовать байтовое представление в базовый тип.

```csharp
var bytesArray = BitConverter.GetBytes(1.0d); //Получить представление 1 типа double в виде массива байт

// 1.0d представленное как массив байтов: 0-0-0-0-0-0-240-63
Console.WriteLine($"1.0d представленное как массив байтов: {string.Join("-", bytesArray)}"); 

//1.0d представленное как массив байтов в виде 16-ричных чисел: 00-00-00-00-00-00-F0-3F
Console.WriteLine($"1.0d представленное как массив байтов в виде 16-ричных чисел: {BitConverter.ToString(bytesArray)}"); 
```

Double занимает 8 байтов в памяти и метод `GetBytes` возвращает нам массив из 8 элементов.

Но для разбора удобнее числа представлять в двоичной системе исчисления. Можно для этого каждый элемент массива представить в двоичном виде.

```csharp
//Reverse для того, чтобы изменить обратный порядок байтов, который используется процессором, на прямой
var bytesArray = BitConverter.GetBytes(1.0d).Reverse();
//Convert.ToString не возвращает старшие разряды байта, равные 0, поэтому используем PadLeft
Console.WriteLine($"1.0d в двоичной системе исчисления: {string.Join("", bytesArray.Select(ba => Convert.ToString(ba, 2).PadLeft(8, '0')))}"); 
//1.0d в двоичной системе исчисления: 0011111111110000000000000000000000000000000000000000000000000000
```

А можно воспользоваться методом `DoubleToInt64Bits` - он возвращает 64 битное целое число, которое в двоичном виде соответствует байтовому представлению числа типа double.

```csharp
var oneinlong = BitConverter.DoubleToInt64Bits(1.0d);
//Convert.ToString не возвращает старшие разряды 64 разрядного целого числа, равные 0, поэтому используем PadLeft
var onebinary = Convert.ToString(oneinlong, 2).PadLeft(64, '0');
Console.WriteLine($"1.0d в двоичной системе исчисления: {onebinary}");
//1.0d в двоичной системе исчисления: 0011111111110000000000000000000000000000000000000000000000000000
```

## Разберём некоторые нормализованные числа

_Определение нормализованного числа_

Для разобра удобнее сразу разделить число на его основные составляющие: фракцию, экспоненту и знак. Знак хранится в старшем бите, следующие 11 старших бит занимает экспонента, оставшиеся 52 бита фракция.

```csharp
Console.WriteLine("sign   " + "exponent      " + "fraction   ");
Console.WriteLine(onebinary[0].ToString().PadRight(7) + string.Concat(onebinary.Skip(1).Take(11)).PadRight(14) + string.Concat(onebinary.Skip(12).Take(52)));
//sign   exponent      fraction   
//0      01111111111   0000000000000000000000000000000000000000000000000000
```

Берём мантиссу прибавляем неявную единицу впереди получается: 10100000000000000000000000000000000000000000000000000
Это число умножаем на 2^52 (N-1) - получаем 1.25
Экспонента 1025 со смещением 1023 получается, что актуальная экспонента 2
1.25 * 4 = 5
