---
layout: post
title: Представление чисел с плавающей точкой в памяти в дотнете
tags: floating-point-numbers
published: false
---

Это не полноценная статья, я не смогу подробно и доступно рассказать о устройстве чисел с плавающей точкой, а порекомендую ссылки на другие статьи рассказывающие об этом (хотя и их тоже не назовёшь идеальными):

У Джона Скита есть две коротенькие статьи на эту тему, первая [Binary floating point and .NET](https://csharpindepth.com/Articles/FloatingPoint) про double и float, вторая [Decimal floating point in .NET](https://csharpindepth.com/Articles/Decimal) про decimal, можно сначала прочитать их.

Сам Скит рекомендует к прочтению эту статью: [Floating Point in .NET part 1: Concepts and Formats](https://www.extremeoptimization.com/resources/Articles/FPDotNetConceptsAndFormats.aspx) - она  более подробная и позволит уже более основательно разобраться в вопросе.

В этой статье я только разберу, конкретные байтовые представления чисел в памяти, подробно остановившись на том, как они получаются. Мне кажется, таких конкретных примеров не хватает в статьях выше для лучшего понимания.

## Кратко о том как Double хранится в памяти 
Double занимает в памяти 8 байт или 64 разряда в двоичном представлении. Старший разряд хранит знак числа - 0 это "+", 1 это "-". 11 следующих разрядов занимает экспонента. Оставшиеся 52 - мантисса. Грубо говоря, комбинация этих трёх компонент в виде: `знак * мантисса * 2 ^ экспонента`, с небольшой предварительной манипуляцией над этими компонентами и будет представлять хранимое число. Есть разные классы хранимых чисел: нормализованные, субнормальные, бесконечность и Nan - они отличаются тем, как именно из хранимых компонент получается итоговое число.

## Как можно посмотреть байтовое представление Double
[Класс BitConverter](https://docs.microsoft.com/ru-ru/dotnet/api/system.bitconverter?view=netframework-4.8) позволяет получить байтовое представление базовых типов или наоборот преобразовать байтовое представление в базовый тип.

```csharp
var bytesArray = BitConverter.GetBytes(1.0d); //Получить представление 1 типа double в виде массива байт

// 1.0d представленное как массив байтов: 0-0-0-0-0-0-240-63
Console.WriteLine($"1.0d представленное как массив байтов: {string.Join("-", bytesArray)}"); 

//1.0d представленное как массив байтов в виде 16-ричных чисел: 00-00-00-00-00-00-F0-3F
Console.WriteLine($"1.0d представленное как массив байтов в виде 16-ричных чисел: {BitConverter.ToString(bytesArray)}"); 
```

Double занимает 8 байтов в памяти и метод `GetBytes` возвращает нам массив из 8 элементов.

Но для разбора удобнее числа представлять в двоичной системе исчисления. Можно для этого каждый элемент массива представить в двоичном виде.

```csharp
//Reverse для того, чтобы изменить обратный порядок байтов, который используется процессором, на прямой
var bytesArray = BitConverter.GetBytes(1.0d).Reverse();
//Convert.ToString не возвращает старшие разряды байта, равные 0, поэтому используем PadLeft
Console.WriteLine($"1.0d в двоичной системе исчисления: {string.Join("", bytesArray.Select(ba => Convert.ToString(ba, 2).PadLeft(8, '0')))}"); 
//1.0d в двоичной системе исчисления: 0011111111110000000000000000000000000000000000000000000000000000
```

А можно воспользоваться методом `DoubleToInt64Bits` - он возвращает 64 битное целое число, которое в двоичном виде соответствует байтовому представлению числа типа double.

```csharp
var numberinlong = BitConverter.DoubleToInt64Bits(1.0d);
//Convert.ToString не возвращает старшие разряды 64 разрядного целого числа, равные 0, поэтому используем PadLeft
var numberbinary = Convert.ToString(numberinlong, 2).PadLeft(64, '0');
Console.WriteLine($"1.0d в двоичной системе исчисления: {numberbinary}");
//1.0d в двоичной системе исчисления: 0011111111110000000000000000000000000000000000000000000000000000
```

Для разобра удобнее сразу разделить число на его основные составляющие: фракцию, экспоненту и знак.

```csharp
var sign = numberbinary[0];
var storedexponent = string.Concat(numberbinary.Skip(1).Take(11));
var storedmantissa = string.Concat(numberbinary.Skip(12).Take(52));
Console.WriteLine("sign   " + "stored exponent   " + "stored mantissa");
Console.WriteLine(sign.ToString().PadRight(7) + storedexponent.PadRight(18) + storedmantissa);
//sign   stored exponent   stored mantissa
//0      01111111111       0000000000000000000000000000000000000000000000000000
```

## Как получаются нормализованные числа
Нормализованное число - это способ кодирования чисел лежащих в определённом числовом диапазоне (всех кроме, очень маленьких) в мантиссе и экспоненте Double. Формула для получения итогового числа остаётся: `М (Мантисса) * 2 ^ е (Экспонента)`, но чтобы получить Мантиссу и Экспоненту из данных хранимых в Double, нужно проделать некоторые манипуляции.

В Double для мантиссы отводятся 52 разряда, ещё один старший разряд в нормализованных числах подразумевается и он всегда равен 1. Чтобы из мантиссы хранимой в Double получить настоящую мантиссу, которую нужно умножать на экспоненту, нужно добавить к ней ещё один разряд заполненный 1 и разделить на 2 в степени 52. Например для 1 хранимая мантисса (мы её получили в примере выше): `0000000000000000000000000000000000000000000000000000` - это 52 разряда заполненные нулями, при добавлении ещё одного разряда заполненного единицей получается: `10000000000000000000000000000000000000000000000000000` - это уже 53 разряда с единицей в старшем разряде, при делении этого числа на 2^52 результат будет 1.



Большинство чисел нормализованные - по факту это значит, что мантисса и экспонента у них подобраны таким образом, что если взять мантиссу добавить ей один старшй разряд и установить его в 1, получившееся число разделить на 2 в степени 52 и умножить на 2 в степени: экспонента минус 1023, то мы получим искомое число - звучит не очень понятно.

Давайте попробуем в обратном порядке:

У нас есть число

1. Объяснить зачем делить на 2 ^52
2. Объяснить зачем вычитать 1023

## Разберём некоторые нормализованные числа


```csharp
var storedexponentinint = Convert.ToInt64(storedexponent, 2);
var realexponentinint = storedexponentinint - 1023;
var realmantissa = $"1{storedmantissa}";
var realmantissainint = Convert.ToInt64(realmantissa, 2);

var resultnumber = realmantissainint / Math.Pow(2,52) * Math.Pow(2, realexponentinint);

Console.WriteLine($"{nameof(storedexponentinint)} = {storedexponentinint}");
Console.WriteLine($"{nameof(realexponentinint)} = {nameof(storedexponent)} - 1023 = {realexponentinint}");
Console.WriteLine($"{nameof(realmantissa)}: {realmantissa}");
Console.WriteLine($"{nameof(realmantissainint)}: {realmantissainint}");
Console.WriteLine($"{nameof(resultnumber)} = {nameof(realmantissainint)} / 2^52 * 2^{nameof(realexponentinint)} = {realmantissainint} / 4503599627370496 * {Math.Pow(2, realexponentinint)} = {resultnumber}");
```



Берём мантиссу прибавляем неявную единицу впереди получается: 10100000000000000000000000000000000000000000000000000
Это число делим на 2^52 (N-1) - получаем 1.25
Экспонента 1025 со смещением 1023 получается, что актуальная экспонента 2
1.25 * 4 = 5
