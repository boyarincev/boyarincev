---
layout: post
title: Никто не понимает Open-Closed принцип
tags: SOLID
published: false
---

## В чём проблема принципа

Принцип противоречиво и неясно описан, приходится прилагать очень много ментальных усилий, чтобы понять настоящий смысл этого принципа.

## Определение принципа от Боба Мартина

Краткий экскурс - Мейер, Статья Боба Мартина, почему я начинаю описание с книги, а не со статьи. 

Начнём с определения принципа данного в книге "Принципы, паттерны и методики гибкой разработки на языке C#"

> Программные сущности (класы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для модификации

И дальнейшего краткого объяснения принципа

> Если единственное изменение в каком-то месте программы приводит к каскаду изменений в зависимых модулях, то дизайн попахивает жесткостью. Принцип OCP рекомендует переработать систему так, чтобы в будущем аналогичные изменения можно было реализовать путем добавления нового кода, а не изменения уже работающего. На первый взгляд это кажется недостижимым идеалом, но существуют относительно простые и эффективные способы приблизиться к нему.

Что нам теперь известно о принципе:
1. Если внесение одного какого-либо изменения влечёт каскад изменений в зависимых модулях, то дизайн жёсткий
2. Следование принципу OCP означает, то что внести изменение из первого пункта в программу можно добавлением нового кода, а не изменением старого

Хотя это явно и не проговаривается, но то как построены предложения позволяет предположить, что если мы внесём изменения в программу с помощью добавления нового кода, а не изменения старого, то следствием этого будет, то что внесение такого изменения не повлечёт каскад изменений в зависимых модулях. С другой стороны - это не значит, что внести изменения без каскада изменений можно только следуя принципу OCP.

Теперь давайте поговорим про ценность каждого из этих пунктов. Ценность первого пункта (возможность внести изменения в модуль без каскада изменений в зависимых модулях) очевидна и понятна, ценность второго пункта, а именно: возможность внести изменение добавлением нового кода, а не правки старого - сама по себе не очевидна, да это может быть полезно в каких-то ситуациях, но мы говорим про принцип проектирования, которому должно соответствовать максимальное количество программных сущностей, в определении Боба Мартина нет никаких уточнений или исключений - все программные сущности должны соответствовать принципу OCP. Лично я не готов при проектировании всегда следовать принципу только ради того, чтобы получить возможность внести изменение, добавив новый код, с другой стороны, вероятно, я практически всегда готов был бы следовать тому принципу, который поможет избежать каскада изменений в зависимых модулях. Но как я уже написал выше, на данный момент не говорится, что достижение этой цели возможно только через использование OCP.
