---
layout: post
title: Управление жизненным циклом объектов в Castle Windsor
tags: castle-windsor
published: false
---

Возможно, наиболее непонимаемая вещь в Castle Windsor - это его система управления жизненным циклом объектов. Надеюсь эта запись поможет прояснить некоторые сложные моменты.

# Castle Windsor управляет жизненным циклом создаваемых им объектов

Одна из ключевых обязанностей IoC-контейнера (далее просто контейнер) - это управление жизненным циклом, полученных из него объектов. Контейнер создает объект, настраивает его и отдаем вам, после чего вы можете им пользоваться, а когда объект становится не нужен - уничтожает его. Для того, чтобы знать какие объекты он должен уничтожить, когда придет их время и получить к ним доступ контейнер
хранит ссылки на создаваемые им объекты.

Давайте рассмотрим пример:

```csharp
public class UnitOfWork
{
   public void Init()
   {
      // some initialization logic...
   }
   public void Commit()
   {
      // commit or rollback the UoW
   }
}
```

Мы имеем класс реализующий функционал unit of work. После создания его экземпляра и перед его использованием нам нужно его инициализировать. А после использования зафиксировать всю работу, что мы сделали. Также обычно в веб-приложениях время жизни unit of work должно быть ограничено временем выполнения веб-запроса.

Обязанностью контейнера будет создать экземпляр UnitOfWork, затем вызывать метод Init, мы не должны этого делать, потому что в рамках веб-запроса (будем рассматривать на его примере) может быть множество компонетов, завязаных на один unit of work, и как определить какой из них должен это сделать?

Ответ - никакой. Это не их работа. Они просто должны его использовать. Какой из компонентов должен вызывать Commit? Опять же никакой. Каждый отдельный компонент не знает, когда другие компоненты завершат работу. 

Никто из компонентов не отвечает за этот экземпляр UnitOfWork, так как никто из них не создавал его.

Уничтожение объекта и "очистка" за ним - это тоже часть ответственности контейнера. Обычно в .NET под этим подразумевается вызов метода Dispose у объекта.

## Должен ли я вызывать Dispose метод на объектах полученных из Castle Windsor?

В .NET фреймворке есть довольно простое правило относительно диспосинга объектов:

> Dispose то что вы создали, когда вы закончили использовать его (Dispose what you’ve created, when you’re done using it).

Так как контейнер создал объект, то это его обязанность вызвать dispose метод этого объекта.

Если вы хотите больше узнать о dispose объектов, то вот еще несколько ссылок:

1. [Dispose паттерн в .NET](https://msdn.microsoft.com/en-us/library/b1yfkh5e(v=vs.110).aspx)

2. [Забавный ответ Эрика Липперта о диспосинге объектов](http://stackoverflow.com/a/35567469/5402731)

3. [Первая часть статьи Эрика Липперта о финалайзерах](https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/)

4. [Вторая часть статьи Эрика Липперта о финалайзерах](https://ericlippert.com/2015/05/21/when-everything-you-know-is-wrong-part-two/)

# Что если мои объекты не требуют очистки? Windsor все еще будет отслеживать и хранить ссылки на них?

Настройки того, как Castle Windsor будет отлеживать создаваемые им объекты определяются Release Policy - по сути, это просто объект в котором передаются настройки. По умолчанию Windsor использует LifecycledComponentReleasePolicy. Windsor имеет также альтернативную версию называющуюся NoTrackingReleasePolicy, которая как подразумевается ее именем никогда не отслеживает создаваемые контейнером объекты.

# Ссылки:

1. [Типы жизненных стилей объектов в Castle Windsor](https://github.com/castleproject/Windsor/blob/master/docs/lifestyles.md)

2. [Жизненный цикл объектов в Castle Windsor](https://github.com/castleproject/Windsor/blob/master/docs/lifecycle.md)

3. [Release Policy в Castle Windsor](https://github.com/castleproject/Windsor/blob/master/docs/release-policy.md)
