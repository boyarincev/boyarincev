---
layout: post
title: Управление жизненным циклом объектов в Castle Windsor
tags: castle-windsor
published: false
---

Возможно, наиболее непонимаемая вещь в Castle Windsor - это его система управления жизненным циклом объектов (многие вообще о ней не подозревают). Надеюсь, эта запись поможет прояснить некоторые непонимаемые моменты.

# Castle Windsor и жизненный цикл создаваемых им объектов

Одна из ключевых обязанностей IoC-контейнера (далее просто контейнер) - это управление жизненным циклом, полученных из него объектов. Контейнер создает объект, настраивает его и отдаем вам, после чего вы можете им пользоваться, а когда объект становится не нужен - уничтожает его. Для того, чтобы знать какие объекты он должен уничтожить, когда придет их время и получить к ним доступ контейнер
хранит ссылки на создаваемые им объекты.

Давайте рассмотрим пример:

```csharp
public class UnitOfWork
{
   public void Init()
   {
      // some initialization logic...
   }
   public void Commit()
   {
      // commit or rollback the UoW
   }
}
```

Мы имеем класс реализующий функционал unit of work. После создания его экземпляра и перед его использованием нам нужно его инициализировать. А после использования зафиксировать всю работу, что мы сделали. Также, обычно, в веб-приложениях время жизни unit of work должно быть ограничено временем выполнения веб-запроса.

Обязанностью контейнера будет создать экземпляр UnitOfWork, затем вызывать метод `Init()` - мы не должны этого делать, потому что в рамках веб-запроса (будем рассматривать на его примере) может быть множество компонетов, завязаных на один unit of work, и как определить какой из них должен это сделать?

Ответ - никакой. Это не их работа. Они просто должны его использовать. Какой из компонентов должен вызывать Commit? Опять же никакой. Каждый отдельный компонент не знает, когда другие компоненты завершат работу. 

Никто из компонентов не отвечает за этот экземпляр UnitOfWork, так как никто из них не создавал его.

Уничтожение объекта и "очистка" за ним - это тоже часть ответственности контейнера. Обычно в .NET под этим подразумевается вызов метода `Dispose()` у объекта.

# Должен ли я вызывать Dispose метод на объектах полученных из Castle Windsor?

В .NET фреймворке есть довольно простое правило относительно диспосинга объектов:

> Dispose то что вы создали, когда вы закончили использовать его (Dispose what you’ve created, when you’re done using it).

Так как контейнер создал объект, то это его обязанность вызвать dispose метод этого объекта - вы не должны этого делать.

Если вы хотите больше узнать о dispose объектов, то вот еще несколько ссылок:

1. [Dispose паттерн в .NET](https://msdn.microsoft.com/en-us/library/b1yfkh5e(v=vs.110).aspx)

2. [Забавный ответ Эрика Липперта о диспосинге объектов](http://stackoverflow.com/a/35567469/5402731)

3. [Первая часть статьи Эрика Липперта о финалайзерах](https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/)

4. [Вторая часть статьи Эрика Липперта о финалайзерах](https://ericlippert.com/2015/05/21/when-everything-you-know-is-wrong-part-two/)

# Что если мои объекты не требуют очистки? Windsor все еще будет отслеживать и хранить ссылки на них?

Настройки того, как Castle Windsor будет отлеживать создаваемые им объекты определяются Release Policy, по сути, это объект в котором передаются настройки. По умолчанию, Windsor использует release policy `LifecycledComponentReleasePolicy` - который отслеживает все создаваемые контейнером объекты, до момента когда они не перестанут быть нужны. Windsor имеет также альтернативную версию release policy, называющуюся `NoTrackingReleasePolicy`, которая, как подразумевается ее именем, никогда не отслеживает создаваемые контейнером объекты.

Часто люди рассматривают, то что Windsor хранит ссылки на объекты, как причину утечек памяти (так как .NET Garbage Collector не может удалить объекты из памяти, пока на них есть ссылки в контейнере, это, действительно, может стать проблемой, но только тогда, когда вы используете Windsor неправильно) и решают заменить стандартную политику на `NoTrackingReleasePolicy`, думая, что это решит все проблемы. Однако, в конечном итоге, это может привести только к большей головной боли и к более серьезным сложно отлавливаемым ошибкам и проблемам.

# Должен ли я релизить всё, когда использую Windsor?

Как я упомянул в предыдущем параграфе, Windsor хранит ссылки на созданные объекты, до момент когда они не перестанут быть нужны и некоторые пользователи думают, что в порядке правильного освобождения компонетов, для того чтобы избежать проблем с утечкой памяти, они должны вызывать метод `Release()` контейнера для всех объектов, которые они получили из него:

```
   container.Release(myComponent);
```

Чтобы дать понять контейнеру, что они больше не нуждаются в этих объектах. Это не совсем так.

# Как Windsor понимает, что вы больше не нуждаетесь в этих объектах

В Castle Windsor каждый компонент имеет Lifestyle ассоциированный с ним. Этот lifestyle определяет контекст в котором экземпляр объекта существует. Если вы хотите, чтобы объект существовал в единственном экземпляре на весь контейнер, вы даете этому объекту Singleton lifestyle. Если вы хотите использовать один и тот же объект в рамках веб-запроса, вы даете ему lifesyle per-web-request и т.д..

# Когда оканчивается контект?

Тогда как некоторые контексты, например, такие как веб-запрос, имеют явно определенный конец, который Windsor может отследить, другие контекты не имеют его. И это приводит нас к использованию метода `Release()`.

Windsor контейнер имеет метод `Release()`, используя который вы можете явно сказать: "Хей, я больше не нуждаюсь в этом объекте". Хотя название метода звучит довольно императивно, подразумевая немеделенное действие, это часто не так. И между вызовом метода и действиями по уничтожению объекта может пройти довольно много времени. Время когда объект будет действительно уничтожен определяет менеджер используемого для компонента lifestyle.

- Singleton будет игнорировать ваши вызовы `Release()` потому что экземпляр существует в контексте жизни всего контейнера и то что вам этот объект сейчас не нужен, не значит, что он не нужен сейчас в каком-то другом месте программы или не понадобится мгновением позже. Контекст singleton lifestyle имеет явно определенный конец - это момент когда будет disposed сам Windsor контейнер. Это значит, что нет смысла вызывать `Release()` на объектах с singleton lifesyle.

- Per-web-request будет игнорировать ваши вызовы `Relese()` по похожим причинам что и выше - экземпляр существует в рамках веб-запроса. Веб-запрос тоже имеет явно определенный конец, поэтому объекты с таким lifestyle будут разрушаться во время окончания веб-запроса. Это также значит, что от вас никаких действий не требуется, Windsor сам определит, момент для необходимых действий.

- Per-thread это подобно синглтону, только в контексте существования каждого отдельного потока. `Releae()` per-thread компонентов ни к чему не приведет, они будут уничтожаться, только когда контейнер будет disposed.

- Scoped вы сами определяете начало и окончание времени жизни контекста в котором существует экземпляр объекта. Поэтому `Release()` точно также не будет иметь никакого эффекта, пока scope в котором был создан этот объект не будет завершен.

- Pooled экземпляры отличаются от предыдущих. Они не имеют явно определенного окончания, поэтому вам необходимо вызывать `Release()` когда объект вам больше не нужен, чтобы Windsor мог либо возвратить его в пул, либо уничтожить (в зависимости от текущей ситуации и настроек пула).

- Transient экземпляры подобны Pooled, потому что тоже не имеют явно определенного окончания. И Windsor не знает, нужен вам этот объект еще или нет, пока вы явно не скажете ему об этом (через вызов `Release()`). Так как transient экземпляры не используются совместно с кем-нибудь еще, то они будут немедленно уничтожены, после вызова `Release()`.

Если вы сейчас чешете голову и думаете: "Windsor реально кладет на меня всю эту работу по освобождению объектов?" - не беспокойтесь. В реальности вы почти никогда не должны вызывать `Release()` явно в вашем приложении.

# Вы почти никогда не должны вызывать Release метод контейнера явно

Release одного компонента приводит к release целого графа зависимых от него объектов. Как я писал в предыдущем параграфае, Windsor определяет окончание жизни объектов используях их lifesyle самостоятельно.

Допустим, вы имеете per-web-request ShoppingCard компонент в вашем приложении, который зависит от transient PaymentCalculatorService и singleton AuditWriter, когда веб-запрос завершится, Windsor будет релизить ShoppingCard со всеми его зависимостями. Так как AuditWriter - это singleton, то это не будет иметь какого-либо влияния на него и он продолжит свое существование, но PaymentCalculatorService (также как и сам ShoppingCard) будет уничтожен, без какой-либо явной работы с вашей стороны.

Тоже самое происходит и при использовании [Типизированных фабрик](https://github.com/castleproject/Windsor/blob/master/docs/typed-factory-facility-interface-based.md) - когда фабрика релизится, все компоненты, что вы получили из нее, будут релизиться также. Однако вам необходимо быть осторожными - если вы получаете слишком много объектов из фабрики, а время жизни фабрика велико (например, singleton) вы можете окончить с тем, что слишком много компонентов будет находиться в памяти, что вызовет утечку памяти.

Предположим, вы пишете веб-браузер и имеете фабрику вкладок, которая создает вкладки, для отображения из в браузере. Эта фабрика будет иметь singleton lifestyle в вашем приложении, но вкладки, которые она производит будут transient - пользователь может открыть вкладку, затем закрыть ее, затем открыть еще несколько и снова их закрыть. Наверное, вы сталкивались с тем, как быстро заканчивается оперативная память, когда у вас много открытых вкладок в браузере, поэтому ждать пока контейнер будет полностью уничтожен, чтобы освободить память от давно закрытых вкладок будет неправильно.

Наиболее вероятно, что вы хотели бы сказать Windsor release вкладку сразу после ее закрытия, Это довольно просто сделать используя `Release()` метод интерфейса вашей типизированной фабрики, который вы будете вызывать, когда пользователь закрывает вкладку. Вы скажете, что нет разницы какой `Release()` метод вызывать Windsor контейнера или вашей фабрики, но по-настоящему это не так, семантически разница велика - вы вызываете метод являющийся частью вашего интерфейса и частью вашей бизнес-логики, а не стороннего компонента.

Пример интерфейса типизированной фабрики:

```
   public interface IDummyComponentFactory
   {
        IDummyComponent Create();
        void Release(IDummyComponent dummyComponent);
   }
```

Регистрация типизированной фабрики в контейнере:

```
   kernel.AddFacility<TypedFactoryFacility>();
   kernel.Register(
       Component.For<IDummyComponent>()
         .ImplementedBy<Calendar>().LifeStyle.Transient,
       Component.For<IDummyComponentFactory>()
         .AsFactory()
   );
```

Использование фабрики:

```
   var factory = kernel.Resolve<IDummyComponentFactory>();
   var component = factory.Create();
   ...
   factory.Release(component);
```

# Место где вы все-таки должны вызывать Release явно

Для того, чтобы определить где вы должны вызывать `Release()` есть простое правило:

> Вы должны релизить те объекты, которые явно резолвили, тогда когда закончили работу с ними.

Например, если вы используете фабричный метод для создания объекта, используя другой объект, вам необходимо релизить этот второй объект, после того как он перестанет быть вам нужен.

```
   container.Register(
      Component.For<ITaxCalculator>()
         .UsingFactoryMethod(k =>
         {
            var country = k.Resolve<ICountry>(user.CountryCode);
            var taxCalculator = country.GetTaxCalculator();
            k.Release(country);
            return taxCalculator;
         })
      );
```

Если вы явно получаете из контейнера фабрику, то вы явно должны релизить ее:

```
   var factory = kernel.Resolve<IDummyComponentFactory>();
   ...
   kernel.Release(factory);
```

Но только саму фабрику, а не объекты, которые получили из нее. И помните, что использование Ioc-контейнера в качестве Service Locator - это антипаттер и в идеале весь код явного получения объектов из контейнера должен быть сосредоточен в корне приложения и инкапсулирован от других частей системы - это вопрос грамотного дизайна приложения.

# Ссылки:

1. [Типы жизненных стилей объектов в Castle Windsor](https://github.com/castleproject/Windsor/blob/master/docs/lifestyles.md)

2. [Жизненный цикл объектов в Castle Windsor](https://github.com/castleproject/Windsor/blob/master/docs/lifecycle.md)

3. [Release Policy в Castle Windsor](https://github.com/castleproject/Windsor/blob/master/docs/release-policy.md)

4. [Typed Factory](https://github.com/castleproject/Windsor/blob/master/docs/typed-factory-facility.md)

5. [Castle Windsor и утечки памяти](http://tommarien.github.io/blog/2012/04/21/castle-windsor-avoid-memory-leaks-by-learning-the-underlying-mechanics)
